# Data Directory

This directory serves as the workspace for the application's data ingestion pipeline. It contains the input files, intermediate processed files, and the final output data.

**IMPORTANT:** With the exception of sample input files, the contents of this directory are generated by the application at runtime. They are intentionally excluded from the Git repository via the `.gitignore` file and should **not** be committed.

## Directory Structure and Data Flow

```
data/
├── input/
│ └── pdf <-- STEP 1: Ρaw PDFs are placed here
├── processed/
│ ├── txt <-- STEP 2: PDF parser writes .txt files here
│ └── json <-- STEP 3: Text parser writes .json files here
└── output/
   └── sql <-- STEP 4: JSON loader writes final .sql files here
```

### 1. `input/`

*   **Purpose:** Contains the source PDF documents that need to be processed.
*   **Process:** This is the starting point of the pipeline. The `PdfReader` program in the `com.budgetingestion.pdf` package reads files from this directory.

### 2. `processed/`

This directory holds the intermediate files that are generated during the pipeline. These are useful for debugging the process at each step.

*   **`processed/txt/`**
    *   **Purpose:** Stores the raw text extracted from the PDFs.
    *   **Process:** Created by the `PdfReader` program. Read by the `TextToJsonParser` program.

*   **`processed/json/`**
    *   **Purpose:** Stores the structured JSON data created from the raw text.
    *   **Process:** Created by the `TextToJsonParser` program. Read by the `JsonToSqlLoader` program.

### 3. `output/sql/`

*   **Purpose:** Contains the final, consumable output of the pipeline.
*   **Process:** The `.sql` files in this directory are generated by the `JsonToSqlLoader` program. They can then be used by other teams or processes to load the data into a database.

------------------------------------------------------------------------------------------
Database Schema

The data is stored in a relational SQLite database with the following structure. Understanding this schema is key to writing your own queries.

*   `Budgets`: The main table containing one record per budget year, with metadata and overall totals.
    *   `budget_id` (Primary Key)
    *   `budget_year` (e.g., 2025)
    *   `total_revenue`, `total_expenses`, etc.

*   `RevenueCategories`: Stores the hierarchical revenue data.
    *   `revenue_category_id` (Primary Key)
    *   `budget_id` (Foreign Key to `Budgets`)
    *   `code` (e.g., '11', '111')
    *   `name` (e.g., 'Φόροι')
    *   `amount`
    *   `parent_id` (Foreign Key to itself, linking a child to its parent category)

*   `ExpenseCategories`: A flat list of all major expense categories.
    *   `expense_category_id` (Primary Key)
    *   `budget_id` (Foreign Key to `Budgets`)
    *   `code` (e.g., '21')
    *   `name`, `amount`

*   `Ministries`: Contains a record for each government ministry or body.
    *   `ministry_id` (Primary Key)
    *   `budget_id` (Foreign Key to `Budgets`)
    *   `code` (e.g., '1015')
    *   `name`, `total_budget`, etc.

*   `MinistryExpenses`: A link table connecting ministries to their expenses.
    *   `ministry_id` (Foreign Key to `Ministries`)
    *   `expense_category_id` (Foreign Key to `ExpenseCategories`)
    *   `amount`

### . How to Query the Database

#### Recommended Tool
The easiest way to explore the database is with a graphical tool. We recommend **[DB Browser for SQLite](https://sqlitebrowser.org/)**, which is a free, open-source tool available for Windows, macOS, and Linux. Simply open the `greek_budget_data.db` file with this application to browse tables and run SQL queries.

#### Example SQL Queries
```
Here are some useful queries to get you started.

1. Get Total Revenue and Expenses for a Specific Year

SELECT 
    budget_year, 
    total_revenue, 
    total_expenses 
FROM 
    Budgets 
WHERE 
    budget_year = 2025;

    
2. Get Top-Level Revenue Categories for a Year
This query finds all revenue categories that have no parent.


SELECT 
    code, 
    name, 
    amount 
FROM 
    RevenueCategories
WHERE 
    budget_id = (SELECT budget_id FROM Budgets WHERE budget_year = 2025)
    AND parent_id IS NULL;


    
4. Drill Down: Get Children of a Specific Revenue Category (e.g., '11' - Φόροι)
This is the core query for building a tree-like view in a UI.
code
SQL
SELECT 
    code, 
    name, 
    amount 
FROM 
    RevenueCategories
WHERE 
    parent_id = (
        SELECT revenue_category_id 
        FROM RevenueCategories 
        WHERE code = '11' 
        AND budget_id = (SELECT budget_id FROM Budgets WHERE budget_year = 2025)
    );

   
5. Get the Expense Breakdown for a Specific Ministry (e.g., Ministry of Health, code '1015')
This query joins multiple tables to provide a detailed report.

SELECT 
    m.name AS MinistryName,
    ec.code AS ExpenseCode,
    ec.name AS ExpenseName,
    me.amount AS ExpenseAmount
FROM 
    MinistryExpenses AS me
JOIN 
    Ministries AS m ON me.ministry_id = m.ministry_id
JOIN 
    ExpenseCategories AS ec ON me.expense_category_id = ec.expense_category_id
WHERE 
    m.code = '1015'
    AND m.budget_id = (SELECT budget_id FROM Budgets WHERE budget_year = 2025);

```


Θα ήθελα να σας ενημερώσω ότι το μέρος του κώδικα που μου είχε ανατεθεί, έχει πλέον ολοκληρωθεί.   
Για οποιαδήποτε διευκρίνιση ή απορία σχετικά με τα προγράμματα, παρακαλώ επικοινωνήστε μαζί μου ή με τον Στέφανο.  
Είμαι στη διάθεσή σας να συνδράμω και σε άλλους τομείς, εφόσον υπάρχει ανάγκη.




    
